import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.ac004ed7.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"font-end/js/iq.md","filePath":"font-end/js/iq.md","lastUpdated":1700112566000}'),p={name:"font-end/js/iq.md"},e=l(`<h2 id="_1-js-数据类型" tabindex="-1">1.JS 数据类型 <a class="header-anchor" href="#_1-js-数据类型" aria-label="Permalink to &quot;1.JS 数据类型&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">基本数据类型：Number String Boolean Null Undefined BigInt Symbol</span></span>
<span class="line"><span style="color:#e1e4e8;">引用数据类型：Object(包括Array Date 正则 Function Object Map Set WeakMap WeakSet)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">基本数据类型：Number String Boolean Null Undefined BigInt Symbol</span></span>
<span class="line"><span style="color:#24292e;">引用数据类型：Object(包括Array Date 正则 Function Object Map Set WeakMap WeakSet)</span></span></code></pre></div><h2 id="_2-包装类型" tabindex="-1">2.包装类型 <a class="header-anchor" href="#_2-包装类型" aria-label="Permalink to &quot;2.包装类型&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">为了能在基本数据类型上执行操作，JS提供了相应的包装类型:</span></span>
<span class="line"><span style="color:#e1e4e8;">Number String Boolean</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">为了能在基本数据类型上执行操作，JS提供了相应的包装类型:</span></span>
<span class="line"><span style="color:#24292e;">Number String Boolean</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>“装箱”<br> 在读取基本数据类型的方法和属性时，JS 会自动将基本数据类型转化为包装类型，这种自动转换被称为装箱</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//例子</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> str </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Hello&quot;</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 基本数据类型</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> strObj </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> str.</span><span style="color:#B392F0;">toUpperCase</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 自动装箱并调用String对象的toUpperCase方法</span></span>
<span class="line"><span style="color:#E1E4E8;">str.</span><span style="color:#79B8FF;">constructor</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">//自动装箱读取String对象的constructor属性</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//例子</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> str </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Hello&quot;</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 基本数据类型</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> strObj </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> str.</span><span style="color:#6F42C1;">toUpperCase</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 自动装箱并调用String对象的toUpperCase方法</span></span>
<span class="line"><span style="color:#24292E;">str.</span><span style="color:#005CC5;">constructor</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">//自动装箱读取String对象的constructor属性</span></span></code></pre></div></div><h2 id="_3-如何判断-js-数据类型" tabindex="-1">3.如何判断 JS 数据类型 <a class="header-anchor" href="#_3-如何判断-js-数据类型" aria-label="Permalink to &quot;3.如何判断 JS 数据类型&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">1.typeof 基本数据类型</span></span>
<span class="line"><span style="color:#e1e4e8;">2.instanceof 引用数据类型，通过原型链</span></span>
<span class="line"><span style="color:#e1e4e8;">3.Object.prototype.toString.call()</span></span>
<span class="line"><span style="color:#e1e4e8;">4.constructor</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">1.typeof 基本数据类型</span></span>
<span class="line"><span style="color:#24292e;">2.instanceof 引用数据类型，通过原型链</span></span>
<span class="line"><span style="color:#24292e;">3.Object.prototype.toString.call()</span></span>
<span class="line"><span style="color:#24292e;">4.constructor</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Object.prototype.toString.call()可以检测数据类型，为什么对象 obj.toString 就不行<br> 因为 Object 的 toString 是 Object 原型上的方法，而 Array\\Function 这些 Object 的实例对象，他们的 toString 都重写了相应的 toString，所以不同</p></div><h2 id="_4-如何判断两个对象相等" tabindex="-1">4.如何判断两个对象相等 <a class="header-anchor" href="#_4-如何判断两个对象相等" aria-label="Permalink to &quot;4.如何判断两个对象相等&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">1.</span><span style="color:#E1E4E8;"> 使用JSON.</span><span style="color:#B392F0;">stringify</span><span style="color:#E1E4E8;">(obj) 来判断，但是如何两个对象中key顺序不同就会出错</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//2.</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">deepEqual</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">a</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">b</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (a </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> b) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;object&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> b </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;object&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> b </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">aKeys</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Object.</span><span style="color:#B392F0;">keys</span><span style="color:#E1E4E8;">(a)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">bKeys</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Object.</span><span style="color:#B392F0;">keys</span><span style="color:#E1E4E8;">(b)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (aKeys.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> bKeys.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> key </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> aKeys) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">b.</span><span style="color:#B392F0;">hasOwnProperty</span><span style="color:#E1E4E8;">(key) </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#B392F0;">deepEqual</span><span style="color:#E1E4E8;">(a[key], b[key])) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">1.</span><span style="color:#24292E;"> 使用JSON.</span><span style="color:#6F42C1;">stringify</span><span style="color:#24292E;">(obj) 来判断，但是如何两个对象中key顺序不同就会出错</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//2.</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">deepEqual</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">a</span><span style="color:#24292E;">, </span><span style="color:#E36209;">b</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (a </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> b) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;object&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> b </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;object&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> b </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">aKeys</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Object.</span><span style="color:#6F42C1;">keys</span><span style="color:#24292E;">(a)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">bKeys</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Object.</span><span style="color:#6F42C1;">keys</span><span style="color:#24292E;">(b)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (aKeys.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> bKeys.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> key </span><span style="color:#D73A49;">of</span><span style="color:#24292E;"> aKeys) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">b.</span><span style="color:#6F42C1;">hasOwnProperty</span><span style="color:#24292E;">(key) </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">deepEqual</span><span style="color:#24292E;">(a[key], b[key])) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span></code></pre></div><h2 id="_5-如何判空对象" tabindex="-1">5.如何判空对象 <a class="header-anchor" href="#_5-如何判空对象" aria-label="Permalink to &quot;5.如何判空对象&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Reflect.</span><span style="color:#B392F0;">ownKeys</span><span style="color:#E1E4E8;">(obj).</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Reflect.</span><span style="color:#6F42C1;">ownKeys</span><span style="color:#24292E;">(obj).</span><span style="color:#005CC5;">length</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span></code></pre></div><h2 id="_6-为什么-0-1-0-2-0-3" tabindex="-1">6.为什么 0.1 + 0.2 !== 0.3 <a class="header-anchor" href="#_6-为什么-0-1-0-2-0-3" aria-label="Permalink to &quot;6.为什么 0.1 + 0.2 !== 0.3&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">因为在相加计算时，发生了两次精度丢失。</span></span>
<span class="line"><span style="color:#e1e4e8;">JS中Number类型是双精度浮点型，由于0.1转化为二进制是一个无限循环二进制数。但是内存保存的二进制浮点数的小数位数只有52位，所以发生了第一次精度丢失</span></span>
<span class="line"><span style="color:#e1e4e8;">当0.1 + 0.2做加操作时要对阶，0.1的阶数比0.2小，所以0.1的尾数位要右移，发生第二次精度丢失</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">因为在相加计算时，发生了两次精度丢失。</span></span>
<span class="line"><span style="color:#24292e;">JS中Number类型是双精度浮点型，由于0.1转化为二进制是一个无限循环二进制数。但是内存保存的二进制浮点数的小数位数只有52位，所以发生了第一次精度丢失</span></span>
<span class="line"><span style="color:#24292e;">当0.1 + 0.2做加操作时要对阶，0.1的阶数比0.2小，所以0.1的尾数位要右移，发生第二次精度丢失</span></span></code></pre></div><h2 id="_7-类型转换" tabindex="-1">7.类型转换 <a class="header-anchor" href="#_7-类型转换" aria-label="Permalink to &quot;7.类型转换&quot;">​</a></h2><h3 id="_7-1-显式类型转换-he-隐式类型转换" tabindex="-1">7.1 显式类型转换 he 隐式类型转换 <a class="header-anchor" href="#_7-1-显式类型转换-he-隐式类型转换" aria-label="Permalink to &quot;7.1 显式类型转换 he 隐式类型转换&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">通过包装类型进行转换</span></span>
<span class="line"><span style="color:#B392F0;">Number</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;123&#39;</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">//123</span></span>
<span class="line"><span style="color:#B392F0;">Number</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">//0</span></span>
<span class="line"><span style="color:#B392F0;">Number</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">//0</span></span>
<span class="line"><span style="color:#B392F0;">Number</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;&#39;</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">//0</span></span>
<span class="line"><span style="color:#B392F0;">Number</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">undefined</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">//NaN</span></span>
<span class="line"><span style="color:#B392F0;">Number</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;学习&#39;</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">//NaN</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">引用类型转化为数字类型</span></span>
<span class="line"><span style="color:#E1E4E8;">1.调用对象自带的valueOf,若返回的是一个基本类型，就转换为数字类型返回</span></span>
<span class="line"><span style="color:#E1E4E8;">2.调用对象的toString方法，若返回的是一个基本类型，就转换为数字类型返回</span></span>
<span class="line"><span style="color:#E1E4E8;">3.报错</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">Number</span><span style="color:#E1E4E8;">([]) </span><span style="color:#6A737D;">//0</span></span>
<span class="line"><span style="color:#B392F0;">Number</span><span style="color:#E1E4E8;">([</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]) </span><span style="color:#6A737D;">//NaN</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">引用类型转化为字符串</span></span>
<span class="line"><span style="color:#E1E4E8;">1.调用对象的toString方法，若返回的是一个基本类型，就转换为数字类型返回</span></span>
<span class="line"><span style="color:#E1E4E8;">2.调用对象自带的valueOf,若返回的是一个基本类型，就转换为数字类型返回</span></span>
<span class="line"><span style="color:#E1E4E8;">3.报错</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">String</span><span style="color:#E1E4E8;">({}) </span><span style="color:#6A737D;">//&#39;[object object]&#39;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">通过包装类型进行转换</span></span>
<span class="line"><span style="color:#6F42C1;">Number</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;123&#39;</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">//123</span></span>
<span class="line"><span style="color:#6F42C1;">Number</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">false</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">//0</span></span>
<span class="line"><span style="color:#6F42C1;">Number</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">//0</span></span>
<span class="line"><span style="color:#6F42C1;">Number</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;&#39;</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">//0</span></span>
<span class="line"><span style="color:#6F42C1;">Number</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">undefined</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">//NaN</span></span>
<span class="line"><span style="color:#6F42C1;">Number</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;学习&#39;</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">//NaN</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">引用类型转化为数字类型</span></span>
<span class="line"><span style="color:#24292E;">1.调用对象自带的valueOf,若返回的是一个基本类型，就转换为数字类型返回</span></span>
<span class="line"><span style="color:#24292E;">2.调用对象的toString方法，若返回的是一个基本类型，就转换为数字类型返回</span></span>
<span class="line"><span style="color:#24292E;">3.报错</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">Number</span><span style="color:#24292E;">([]) </span><span style="color:#6A737D;">//0</span></span>
<span class="line"><span style="color:#6F42C1;">Number</span><span style="color:#24292E;">([</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]) </span><span style="color:#6A737D;">//NaN</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">引用类型转化为字符串</span></span>
<span class="line"><span style="color:#24292E;">1.调用对象的toString方法，若返回的是一个基本类型，就转换为数字类型返回</span></span>
<span class="line"><span style="color:#24292E;">2.调用对象自带的valueOf,若返回的是一个基本类型，就转换为数字类型返回</span></span>
<span class="line"><span style="color:#24292E;">3.报错</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">String</span><span style="color:#24292E;">({}) </span><span style="color:#6A737D;">//&#39;[object object]&#39;</span></span></code></pre></div><h2 id="_8-和-的区别" tabindex="-1">8.===和==的区别 <a class="header-anchor" href="#_8-和-的区别" aria-label="Permalink to &quot;8.===和==的区别&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">===严格相等运算符（比较变量的值和类型是否相等）</span></span>
<span class="line"><span style="color:#e1e4e8;">==宽松相等运算符（先将变量进行类型转换，再比较值是否相等）</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">===严格相等运算符（比较变量的值和类型是否相等）</span></span>
<span class="line"><span style="color:#24292e;">==宽松相等运算符（先将变量进行类型转换，再比较值是否相等）</span></span></code></pre></div><h2 id="_9-null-和-undefined-的区别" tabindex="-1">9.null 和 undefined 的区别 <a class="header-anchor" href="#_9-null-和-undefined-的区别" aria-label="Permalink to &quot;9.null 和 undefined 的区别&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">null 表示没有对象，此处不该有值，代表一个空对象指针</span></span>
<span class="line"><span style="color:#e1e4e8;">undefined 表示缺少值，此处应该有值，但未定义</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">null 表示没有对象，此处不该有值，代表一个空对象指针</span></span>
<span class="line"><span style="color:#24292e;">undefined 表示缺少值，此处应该有值，但未定义</span></span></code></pre></div><h2 id="_10-什么情况下会返回-undefined" tabindex="-1">10.什么情况下会返回 undefined <a class="header-anchor" href="#_10-什么情况下会返回-undefined" aria-label="Permalink to &quot;10.什么情况下会返回 undefined&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">1.当访问一个声明但未赋值或者赋值为undefined的变量</span></span>
<span class="line"><span style="color:#e1e4e8;">2.当访问一个对象中不存在的属性</span></span>
<span class="line"><span style="color:#e1e4e8;">3.当访问一个没有return或者rentur没有内容的函数</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">1.当访问一个声明但未赋值或者赋值为undefined的变量</span></span>
<span class="line"><span style="color:#24292e;">2.当访问一个对象中不存在的属性</span></span>
<span class="line"><span style="color:#24292e;">3.当访问一个没有return或者rentur没有内容的函数</span></span></code></pre></div><h2 id="_11-如何区分对象和数组" tabindex="-1">11.如何区分对象和数组 <a class="header-anchor" href="#_11-如何区分对象和数组" aria-label="Permalink to &quot;11.如何区分对象和数组&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//instanceof</span></span>
<span class="line"><span style="color:#E1E4E8;">[] </span><span style="color:#F97583;">instanceof</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">Array</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//true</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//constructor</span></span>
<span class="line"><span style="color:#E1E4E8;">    []</span></span>
<span class="line"><span style="color:#E1E4E8;">  ).</span><span style="color:#79B8FF;">constructor</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">//Array</span></span>
<span class="line"><span style="color:#6A737D;">//Object.prototype.toString.call</span></span>
<span class="line"><span style="color:#79B8FF;">Object</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;">.toString.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">([]); </span><span style="color:#6A737D;">//[object Array]</span></span>
<span class="line"><span style="color:#6A737D;">//Array.isArray</span></span>
<span class="line"><span style="color:#E1E4E8;">Array.</span><span style="color:#B392F0;">isArray</span><span style="color:#E1E4E8;">([]); </span><span style="color:#6A737D;">//true</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//instanceof</span></span>
<span class="line"><span style="color:#24292E;">[] </span><span style="color:#D73A49;">instanceof</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">Array</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//true</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//constructor</span></span>
<span class="line"><span style="color:#24292E;">    []</span></span>
<span class="line"><span style="color:#24292E;">  ).</span><span style="color:#005CC5;">constructor</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">//Array</span></span>
<span class="line"><span style="color:#6A737D;">//Object.prototype.toString.call</span></span>
<span class="line"><span style="color:#005CC5;">Object</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">.toString.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">([]); </span><span style="color:#6A737D;">//[object Array]</span></span>
<span class="line"><span style="color:#6A737D;">//Array.isArray</span></span>
<span class="line"><span style="color:#24292E;">Array.</span><span style="color:#6F42C1;">isArray</span><span style="color:#24292E;">([]); </span><span style="color:#6A737D;">//true</span></span></code></pre></div><h2 id="_12-多维数组如何降维" tabindex="-1">12.多维数组如何降维 <a class="header-anchor" href="#_12-多维数组如何降维" aria-label="Permalink to &quot;12.多维数组如何降维&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">1.数组字符串化</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> arr </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [[</span><span style="color:#79B8FF;">11</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">22</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">33</span><span style="color:#E1E4E8;">],</span><span style="color:#79B8FF;">44</span><span style="color:#E1E4E8;">,[</span><span style="color:#79B8FF;">55</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">66</span><span style="color:#E1E4E8;">]]</span></span>
<span class="line"><span style="color:#E1E4E8;">arr </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;&#39;</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> newArr </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> arr.</span><span style="color:#B392F0;">split</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;,&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">2.递归</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">a</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">arr</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> resArr </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> []</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">toArr</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">arr</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        arr.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">item</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            item </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Array</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">toArr</span><span style="color:#E1E4E8;">(item) </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> resArr.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(item)</span></span>
<span class="line"><span style="color:#E1E4E8;">        })</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">toArr</span><span style="color:#E1E4E8;">(arr)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> resArr</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">3.flat函数</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> arr </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [[</span><span style="color:#79B8FF;">11</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">22</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">33</span><span style="color:#E1E4E8;">],</span><span style="color:#79B8FF;">44</span><span style="color:#E1E4E8;">,[</span><span style="color:#79B8FF;">55</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">66</span><span style="color:#E1E4E8;">]]</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> newArr </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> arr.</span><span style="color:#B392F0;">flat</span><span style="color:#E1E4E8;">()</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">1.数组字符串化</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> arr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [[</span><span style="color:#005CC5;">11</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">22</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">33</span><span style="color:#24292E;">],</span><span style="color:#005CC5;">44</span><span style="color:#24292E;">,[</span><span style="color:#005CC5;">55</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">66</span><span style="color:#24292E;">]]</span></span>
<span class="line"><span style="color:#24292E;">arr </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;&#39;</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> newArr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> arr.</span><span style="color:#6F42C1;">split</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;,&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">2.递归</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">a</span><span style="color:#24292E;">(</span><span style="color:#E36209;">arr</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> resArr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> []</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">toArr</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">arr</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        arr.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(</span><span style="color:#E36209;">item</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            item </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Array</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">toArr</span><span style="color:#24292E;">(item) </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> resArr.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(item)</span></span>
<span class="line"><span style="color:#24292E;">        })</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">toArr</span><span style="color:#24292E;">(arr)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> resArr</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">3.flat函数</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> arr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [[</span><span style="color:#005CC5;">11</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">22</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">33</span><span style="color:#24292E;">],</span><span style="color:#005CC5;">44</span><span style="color:#24292E;">,[</span><span style="color:#005CC5;">55</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">66</span><span style="color:#24292E;">]]</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> newArr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> arr.</span><span style="color:#6F42C1;">flat</span><span style="color:#24292E;">()</span></span></code></pre></div><h2 id="_13-什么是类数组-如何将其转化为真正的数组" tabindex="-1">13.什么是类数组， 如何将其转化为真正的数组 <a class="header-anchor" href="#_13-什么是类数组-如何将其转化为真正的数组" aria-label="Permalink to &quot;13.什么是类数组， 如何将其转化为真正的数组&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">类数组就是类似数组的对象，具有类似数组的索引属性和length属性，可以使用一些数组的方法， 比如for循环，forEach等，</span></span>
<span class="line"><span style="color:#E1E4E8;">JS中常见的类数组有：arguments对象，document.getElements获取的内容， 字符串等</span></span>
<span class="line"><span style="color:#E1E4E8;">如何转化为真正的数组：</span></span>
<span class="line"><span style="color:#E1E4E8;">    1.Array.from</span></span>
<span class="line"><span style="color:#E1E4E8;">    2.Array.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;">.slice.call</span></span>
<span class="line"><span style="color:#E1E4E8;">    3.可迭代对象可以使用扩展运算符</span><span style="color:#F97583;">...</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">类数组就是类似数组的对象，具有类似数组的索引属性和length属性，可以使用一些数组的方法， 比如for循环，forEach等，</span></span>
<span class="line"><span style="color:#24292E;">JS中常见的类数组有：arguments对象，document.getElements获取的内容， 字符串等</span></span>
<span class="line"><span style="color:#24292E;">如何转化为真正的数组：</span></span>
<span class="line"><span style="color:#24292E;">    1.Array.from</span></span>
<span class="line"><span style="color:#24292E;">    2.Array.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">.slice.call</span></span>
<span class="line"><span style="color:#24292E;">    3.可迭代对象可以使用扩展运算符</span><span style="color:#D73A49;">...</span></span></code></pre></div><h2 id="_14-如何遍历对象的属性" tabindex="-1">14.如何遍历对象的属性 <a class="header-anchor" href="#_14-如何遍历对象的属性" aria-label="Permalink to &quot;14.如何遍历对象的属性&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">1.for in循环 （遍历对象可枚举属性，包括自身定义的属性和从原型链继承而来的属性）</span></span>
<span class="line"><span style="color:#E1E4E8;">2.Object.keys（返回一个包含自身属性名的数组）</span></span>
<span class="line"><span style="color:#E1E4E8;">3.Object.entries （返回一个包含键值对的数组）</span></span>
<span class="line"><span style="color:#E1E4E8;">4.Object.getOwnPropertyNames</span></span>
<span class="line"><span style="color:#E1E4E8;">5.Object.getOwnPropertySymbols</span></span>
<span class="line"><span style="color:#E1E4E8;">6.Reflect.ownKeys</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">1.for in循环 （遍历对象可枚举属性，包括自身定义的属性和从原型链继承而来的属性）</span></span>
<span class="line"><span style="color:#24292E;">2.Object.keys（返回一个包含自身属性名的数组）</span></span>
<span class="line"><span style="color:#24292E;">3.Object.entries （返回一个包含键值对的数组）</span></span>
<span class="line"><span style="color:#24292E;">4.Object.getOwnPropertyNames</span></span>
<span class="line"><span style="color:#24292E;">5.Object.getOwnPropertySymbols</span></span>
<span class="line"><span style="color:#24292E;">6.Reflect.ownKeys</span></span></code></pre></div><h2 id="_15-如何给一个按钮绑定两个-onclick-事件" tabindex="-1">15.如何给一个按钮绑定两个 onclick 事件 <a class="header-anchor" href="#_15-如何给一个按钮绑定两个-onclick-事件" aria-label="Permalink to &quot;15.如何给一个按钮绑定两个 onclick 事件&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">通过addEventListener可以依次给按钮添加两个onclick事件</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">通过addEventListener可以依次给按钮添加两个onclick事件</span></span></code></pre></div><h2 id="_16-柯里化" tabindex="-1">16.柯里化 <a class="header-anchor" href="#_16-柯里化" aria-label="Permalink to &quot;16.柯里化&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">指将多变量函数拆解为单变量的多个函数的依次调用，可以将高元函数动态生成批量低元函数</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">指将多变量函数拆解为单变量的多个函数的依次调用，可以将高元函数动态生成批量低元函数</span></span></code></pre></div><h2 id="_17-事件流" tabindex="-1">17.事件流 <a class="header-anchor" href="#_17-事件流" aria-label="Permalink to &quot;17.事件流&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">JS事件分为三种类型</span></span>
<span class="line"><span style="color:#e1e4e8;">1.原始事件类型(冒泡事件类型)：当事件源捕获到事件并响应时，会由内向外响应同类事件</span></span>
<span class="line"><span style="color:#e1e4e8;">2.捕获事件类型：当触发DOM事件时，浏览器会从根节点依次向事件源进行传播事件</span></span>
<span class="line"><span style="color:#e1e4e8;">3.DOM2事件类型(结合了原始事件类型和捕获事件类型):</span></span>
<span class="line"><span style="color:#e1e4e8;">    分为三个阶段：捕获阶段、目标阶段、冒泡阶段</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">JS事件分为三种类型</span></span>
<span class="line"><span style="color:#24292e;">1.原始事件类型(冒泡事件类型)：当事件源捕获到事件并响应时，会由内向外响应同类事件</span></span>
<span class="line"><span style="color:#24292e;">2.捕获事件类型：当触发DOM事件时，浏览器会从根节点依次向事件源进行传播事件</span></span>
<span class="line"><span style="color:#24292e;">3.DOM2事件类型(结合了原始事件类型和捕获事件类型):</span></span>
<span class="line"><span style="color:#24292e;">    分为三个阶段：捕获阶段、目标阶段、冒泡阶段</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>阻止冒泡： w3c e.stopPropagation(), ie e.cancelBubble = true<br> 取消默认事件: w3c e.preventDefault(), ie e.returnValue = false</p></div><h2 id="_18-事件委托" tabindex="-1">18.事件委托 <a class="header-anchor" href="#_18-事件委托" aria-label="Permalink to &quot;18.事件委托&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">将一个元素的响应事件委托到父元素，当事件响应到该元素时，通过事件冒泡触发父元素的绑定事件</span></span>
<span class="line"><span style="color:#e1e4e8;">优点：</span></span>
<span class="line"><span style="color:#e1e4e8;">    1.减少内存消耗，提高性能</span></span>
<span class="line"><span style="color:#e1e4e8;">    2.动态绑定事件</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">将一个元素的响应事件委托到父元素，当事件响应到该元素时，通过事件冒泡触发父元素的绑定事件</span></span>
<span class="line"><span style="color:#24292e;">优点：</span></span>
<span class="line"><span style="color:#24292e;">    1.减少内存消耗，提高性能</span></span>
<span class="line"><span style="color:#24292e;">    2.动态绑定事件</span></span></code></pre></div><h2 id="_19-原型链" tabindex="-1">19.原型链 <a class="header-anchor" href="#_19-原型链" aria-label="Permalink to &quot;19.原型链&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">1.原型： 原型分为隐式原型(_proto_)和显式原型(prototype)， 每个对象都有它的隐式原型，指向它的构造函数的原型对象,构造函数通过显式原型指向原型对象，原型对象通过constructor属性指向构造函数。</span></span>
<span class="line"><span style="color:#e1e4e8;">2.原型链： 当访问一个引用类型时，如果它本身没有这个属性，就会通过它的隐式原型向上级的显示原型中找，直到最顶层的Object为止（Object的原型为null）</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">1.原型： 原型分为隐式原型(_proto_)和显式原型(prototype)， 每个对象都有它的隐式原型，指向它的构造函数的原型对象,构造函数通过显式原型指向原型对象，原型对象通过constructor属性指向构造函数。</span></span>
<span class="line"><span style="color:#24292e;">2.原型链： 当访问一个引用类型时，如果它本身没有这个属性，就会通过它的隐式原型向上级的显示原型中找，直到最顶层的Object为止（Object的原型为null）</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>new 一个对象的过程：<br> 1.创建一个空对象<br> 2.将这个空对象的隐式原型（<em>proto</em>）指向构造函数的原型对象<br> 3.将构造函数的 this 指向空对象<br>4.根据返回值类型选择返回结果</p></div><h2 id="_20-作用域和作用域链" tabindex="-1">20.作用域和作用域链 <a class="header-anchor" href="#_20-作用域和作用域链" aria-label="Permalink to &quot;20.作用域和作用域链&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">1.作用域： JS作用域分为静态作用域（词法作用域）和动态作用域，</span></span>
<span class="line"><span style="color:#e1e4e8;">    其中，静态作用域有全局作用域、函数作用域和块级作用域(es6)，</span></span>
<span class="line"><span style="color:#e1e4e8;">    动态作用域有this上下文</span></span>
<span class="line"><span style="color:#e1e4e8;">2.作用域链： 作用域链是JS中变量查找的一种机制，在函数中，如果无法在当前执行上下文的变量对象中找到某个变量，JS会自动向上一级执行上下文的变量对象中查找，直到最顶层的window对象，这种自动向上查找的过程就是作用域链。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">1.作用域： JS作用域分为静态作用域（词法作用域）和动态作用域，</span></span>
<span class="line"><span style="color:#24292e;">    其中，静态作用域有全局作用域、函数作用域和块级作用域(es6)，</span></span>
<span class="line"><span style="color:#24292e;">    动态作用域有this上下文</span></span>
<span class="line"><span style="color:#24292e;">2.作用域链： 作用域链是JS中变量查找的一种机制，在函数中，如果无法在当前执行上下文的变量对象中找到某个变量，JS会自动向上一级执行上下文的变量对象中查找，直到最顶层的window对象，这种自动向上查找的过程就是作用域链。</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>延长作用域链的方法：<br> 1.闭包 2.eval 函数 3.with 语句（用于临时拓展作用域链，js 严格模式下禁用）</p></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>作用域链和原型链的区别:<br> 1.作用域链相对于变量而言，原型链相对于对象的属性而言<br> 2.作用域链最顶层是 Window，原型链最顶层是 Object</p></div><h2 id="_21-变量提升和函数提升" tabindex="-1">21.变量提升和函数提升 <a class="header-anchor" href="#_21-变量提升和函数提升" aria-label="Permalink to &quot;21.变量提升和函数提升&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">1.变量提升：当我们给一个作用域定义变量时，该变量的声明会被提升到作用域的顶端，所以我们可以在变量声明之前访问到该变量</span></span>
<span class="line"><span style="color:#e1e4e8;">2.函数提升：函数提升和变量提升类似，不过函数提升优先级高于变量提升，因为函数在JS中是一等公民，优先级很很高</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">1.变量提升：当我们给一个作用域定义变量时，该变量的声明会被提升到作用域的顶端，所以我们可以在变量声明之前访问到该变量</span></span>
<span class="line"><span style="color:#24292e;">2.函数提升：函数提升和变量提升类似，不过函数提升优先级高于变量提升，因为函数在JS中是一等公民，优先级很很高</span></span></code></pre></div><h2 id="_22-闭包" tabindex="-1">22.闭包 <a class="header-anchor" href="#_22-闭包" aria-label="Permalink to &quot;22.闭包&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">1.闭包： 通过作用域链实现内部函数变量访问外部函数变量，实现了数据私有化，不会被全局变量污染</span></span>
<span class="line"><span style="color:#e1e4e8;">2.闭包的应用场景：</span></span>
<span class="line"><span style="color:#e1e4e8;">    保护变量</span></span>
<span class="line"><span style="color:#e1e4e8;">    延长变量生命周期</span></span>
<span class="line"><span style="color:#e1e4e8;">    实现数据封装</span></span>
<span class="line"><span style="color:#e1e4e8;">    实现模块化开发</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">1.闭包： 通过作用域链实现内部函数变量访问外部函数变量，实现了数据私有化，不会被全局变量污染</span></span>
<span class="line"><span style="color:#24292e;">2.闭包的应用场景：</span></span>
<span class="line"><span style="color:#24292e;">    保护变量</span></span>
<span class="line"><span style="color:#24292e;">    延长变量生命周期</span></span>
<span class="line"><span style="color:#24292e;">    实现数据封装</span></span>
<span class="line"><span style="color:#24292e;">    实现模块化开发</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>闭包会带来的问题: 内存泄漏</p></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>立即执行函数与闭包：<br> 1.立即执行函数：立即执行函数是一种函数的调用方式，可以让函数在创建后立即执行<br> 2.立即执行函数的作用： 创建一个独立的作用域，作用域内的变量外部访问不到，避免了全局污染<br></p><p>与闭包的区别：<br> 1.立即执行函数调用完后会立即销毁，不会占用内存 2.闭包通过作用域链实现内部函数变量访问外部函数变量，导致被引用的变量不能被垃圾回收机制清除，使用不当会造成内存泄露</p></div><h2 id="_23-内存泄漏" tabindex="-1">23.内存泄漏 <a class="header-anchor" href="#_23-内存泄漏" aria-label="Permalink to &quot;23.内存泄漏&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">1.内存泄漏：内存泄漏是指在程序中已动态分配的堆内存由于某种原因未能被释放或无法释放，造成系统内存的浪费</span></span>
<span class="line"><span style="color:#e1e4e8;">2.造成内存泄漏的原因：</span></span>
<span class="line"><span style="color:#e1e4e8;">    a.隐式全局变量（未声明就使用的变量）—— 解决：使用关键词定义变量或者使用严格模式</span></span>
<span class="line"><span style="color:#e1e4e8;">    b.闭包 —— 解决:将闭包变量置为null</span></span>
<span class="line"><span style="color:#e1e4e8;">    c.未清除的DOM引用 —— 解决：手动将引用设置为null</span></span>
<span class="line"><span style="color:#e1e4e8;">    d.循环引用：当垃圾回收机制为引用计数时会出现</span></span>
<span class="line"><span style="color:#e1e4e8;">    e.定时器 —— 解决：在定时器不再使用的时候清除定时器</span></span>
<span class="line"><span style="color:#e1e4e8;">    f.未清理的console —— 解决： 清理console</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">1.内存泄漏：内存泄漏是指在程序中已动态分配的堆内存由于某种原因未能被释放或无法释放，造成系统内存的浪费</span></span>
<span class="line"><span style="color:#24292e;">2.造成内存泄漏的原因：</span></span>
<span class="line"><span style="color:#24292e;">    a.隐式全局变量（未声明就使用的变量）—— 解决：使用关键词定义变量或者使用严格模式</span></span>
<span class="line"><span style="color:#24292e;">    b.闭包 —— 解决:将闭包变量置为null</span></span>
<span class="line"><span style="color:#24292e;">    c.未清除的DOM引用 —— 解决：手动将引用设置为null</span></span>
<span class="line"><span style="color:#24292e;">    d.循环引用：当垃圾回收机制为引用计数时会出现</span></span>
<span class="line"><span style="color:#24292e;">    e.定时器 —— 解决：在定时器不再使用的时候清除定时器</span></span>
<span class="line"><span style="color:#24292e;">    f.未清理的console —— 解决： 清理console</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>垃圾回收机制：<br> 1.引用计数 2.标记清除 3.分代式回收（V8 的垃圾回收机制，根据对象存活时间进行分代，将内存分为新生代和老生代两块空间）</p></div><h2 id="_24-settimeout-和-setinterval" tabindex="-1">24.setTimeout 和 setInterval <a class="header-anchor" href="#_24-settimeout-和-setinterval" aria-label="Permalink to &quot;24.setTimeout 和 setInterval&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">1.setTimeout:在指定时间后执行一次代码</span></span>
<span class="line"><span style="color:#e1e4e8;">2.setInterval: 每隔一段时间，重复执行一次代码（时间间隔取决于代码的执行时间，如果一次代码的执行时长超出了间隔时间，setInterval会在代码执行完成后立即进行下一次执行，不会等待间隔时间）</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">1.setTimeout:在指定时间后执行一次代码</span></span>
<span class="line"><span style="color:#24292e;">2.setInterval: 每隔一段时间，重复执行一次代码（时间间隔取决于代码的执行时间，如果一次代码的执行时长超出了间隔时间，setInterval会在代码执行完成后立即进行下一次执行，不会等待间隔时间）</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如果期望某一段代码间隔 100ms 执行一次，应该使用嵌套的 setTimeout<br></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mySetInterval</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">fun</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">delay</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> timer;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">interval</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">fun</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    timer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(interval, delay);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  timer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(interval, delay);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">clear</span><span style="color:#E1E4E8;">: () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">clearTimeout</span><span style="color:#E1E4E8;">(timer);</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mySetInterval</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">fun</span><span style="color:#24292E;">, </span><span style="color:#E36209;">delay</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> timer;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">interval</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">fun</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    timer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(interval, delay);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  timer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(interval, delay);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">clear</span><span style="color:#24292E;">: () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">clearTimeout</span><span style="color:#24292E;">(timer);</span></span>
<span class="line"><span style="color:#24292E;">    },</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre></div></div><h2 id="_25-延迟加载" tabindex="-1">25.延迟加载 <a class="header-anchor" href="#_25-延迟加载" aria-label="Permalink to &quot;25.延迟加载&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">在JS中可以通过defer和async让脚本延迟加载</span></span>
<span class="line"><span style="color:#e1e4e8;">1.async：加载完成后立即执行，多个async脚本先下载完的先执行，若DOM未解析完，会阻塞HTML渲染，执行与DOMContentLoaded无关</span></span>
<span class="line"><span style="color:#e1e4e8;">    当执行到async脚本时，会先下载对应的脚本，然后JS继续执行下一个标签，等到async脚本下载完毕时，若DOM正在渲染则暂停渲染，执行async脚本。（多个async脚本先下载完的先执行）</span></span>
<span class="line"><span style="color:#e1e4e8;">2.defer:加载完成后不立即执行，会在DOM解析完成之后，DOMContentLoaded之前执行，多个defer脚本需要等待所有的defer脚本下载完毕后再依次执行，不会阻塞HTML渲染</span></span>
<span class="line"><span style="color:#e1e4e8;">    当执行到defer脚本时，会先下载对应的脚本，然后JS继续执行下一个标签，等到defer脚本下载完毕时，需要等待DOM渲染完毕后执行defer脚本，然后触发DOMContentLoaded的回调(多个defer脚本需要等待所有的defer脚本下载完毕后再依次执行)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">在JS中可以通过defer和async让脚本延迟加载</span></span>
<span class="line"><span style="color:#24292e;">1.async：加载完成后立即执行，多个async脚本先下载完的先执行，若DOM未解析完，会阻塞HTML渲染，执行与DOMContentLoaded无关</span></span>
<span class="line"><span style="color:#24292e;">    当执行到async脚本时，会先下载对应的脚本，然后JS继续执行下一个标签，等到async脚本下载完毕时，若DOM正在渲染则暂停渲染，执行async脚本。（多个async脚本先下载完的先执行）</span></span>
<span class="line"><span style="color:#24292e;">2.defer:加载完成后不立即执行，会在DOM解析完成之后，DOMContentLoaded之前执行，多个defer脚本需要等待所有的defer脚本下载完毕后再依次执行，不会阻塞HTML渲染</span></span>
<span class="line"><span style="color:#24292e;">    当执行到defer脚本时，会先下载对应的脚本，然后JS继续执行下一个标签，等到defer脚本下载完毕时，需要等待DOM渲染完毕后执行defer脚本，然后触发DOMContentLoaded的回调(多个defer脚本需要等待所有的defer脚本下载完毕后再依次执行)</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">1.浏览器会优先下载同步脚本，后下载 defer async 脚本<br> 2.动态插入 JS 与 async 脚本一致<br> 3.适用场景：<br></p><p>1.defer 次屏渲染 广告模块 推荐模块等<br> 2.async PV 埋点等<br></p></div><h2 id="_26-es6-新增" tabindex="-1">26.ES6 新增 <a class="header-anchor" href="#_26-es6-新增" aria-label="Permalink to &quot;26.ES6 新增&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">1.语法：ES6引入了新语法，比如箭头函数、模板字符串、解构赋值、默认参数值、展开运算符等</span></span>
<span class="line"><span style="color:#e1e4e8;">2.作用域： 新增块级作用域，使用let const</span></span>
<span class="line"><span style="color:#e1e4e8;">3.类和模块：使用class关键词定义类，使用import导入export导出模块</span></span>
<span class="line"><span style="color:#e1e4e8;">4.迭代器和生成器：引入Iterator迭代器和generator生成器，迭代器提供了遍历数据结构的通用方式，生成器可以简化异步编程的写法</span></span>
<span class="line"><span style="color:#e1e4e8;">5.Promise：处理异步操作的编程模型</span></span>
<span class="line"><span style="color:#e1e4e8;">6.新的数据结构: Map Set Symbol</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">1.语法：ES6引入了新语法，比如箭头函数、模板字符串、解构赋值、默认参数值、展开运算符等</span></span>
<span class="line"><span style="color:#24292e;">2.作用域： 新增块级作用域，使用let const</span></span>
<span class="line"><span style="color:#24292e;">3.类和模块：使用class关键词定义类，使用import导入export导出模块</span></span>
<span class="line"><span style="color:#24292e;">4.迭代器和生成器：引入Iterator迭代器和generator生成器，迭代器提供了遍历数据结构的通用方式，生成器可以简化异步编程的写法</span></span>
<span class="line"><span style="color:#24292e;">5.Promise：处理异步操作的编程模型</span></span>
<span class="line"><span style="color:#24292e;">6.新的数据结构: Map Set Symbol</span></span></code></pre></div><h2 id="_27-let-const-var-的区别" tabindex="-1">27.let const var 的区别 <a class="header-anchor" href="#_27-let-const-var-的区别" aria-label="Permalink to &quot;27.let const var 的区别&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">1.var具有变量提升，而let const没有(因为let const的声明和初始化两个阶段解耦，同时在这两个阶段中创建了暂时性死区，在初始化之前，变量处于暂时性死区无法访问)</span></span>
<span class="line"><span style="color:#e1e4e8;">2.var 是全局作用域或函数作用域，let const 是块级作用域</span></span>
<span class="line"><span style="color:#e1e4e8;">3.同一作用域下 let const 不能重复声明同名变量，var可以</span></span>
<span class="line"><span style="color:#e1e4e8;">4.const 声明的是常量，必须赋初值，一旦声明的变量不能再次修改，如果是对象，可以修改其中的属性(可以通过object.freeze冻结对象)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">1.var具有变量提升，而let const没有(因为let const的声明和初始化两个阶段解耦，同时在这两个阶段中创建了暂时性死区，在初始化之前，变量处于暂时性死区无法访问)</span></span>
<span class="line"><span style="color:#24292e;">2.var 是全局作用域或函数作用域，let const 是块级作用域</span></span>
<span class="line"><span style="color:#24292e;">3.同一作用域下 let const 不能重复声明同名变量，var可以</span></span>
<span class="line"><span style="color:#24292e;">4.const 声明的是常量，必须赋初值，一旦声明的变量不能再次修改，如果是对象，可以修改其中的属性(可以通过object.freeze冻结对象)</span></span></code></pre></div><h2 id="_28-类的创建和继承" tabindex="-1">28.类的创建和继承 <a class="header-anchor" href="#_28-类的创建和继承" aria-label="Permalink to &quot;28.类的创建和继承&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">1.类的创建: 通过构造函数或者class关键字</span></span>
<span class="line"><span style="color:#e1e4e8;">2.继承：</span></span>
<span class="line"><span style="color:#e1e4e8;">    原型链继承 构造函数继承 组合继承 原型式继承 寄生式继承 寄生组合式继承</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">1.类的创建: 通过构造函数或者class关键字</span></span>
<span class="line"><span style="color:#24292e;">2.继承：</span></span>
<span class="line"><span style="color:#24292e;">    原型链继承 构造函数继承 组合继承 原型式继承 寄生式继承 寄生组合式继承</span></span></code></pre></div><h2 id="_29-this-的指向" tabindex="-1">29.this 的指向 <a class="header-anchor" href="#_29-this-的指向" aria-label="Permalink to &quot;29.this 的指向&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">1.非严格模式下的全局环境,this指向window</span></span>
<span class="line"><span style="color:#e1e4e8;">2.在对象中，属性的this指向外层this， 方法中的this指向调用它的对象</span></span>
<span class="line"><span style="color:#e1e4e8;">3.回调函数中的this指向window（事件回调的this指向e.currentTarget）</span></span>
<span class="line"><span style="color:#e1e4e8;">4.箭头函数中的this指向当前函数外的this（回调函数使用箭头函数时，this指向当前函数外的this）</span></span>
<span class="line"><span style="color:#e1e4e8;">5.构造函数和类的this指向实例化对象,静态方法或属性的this指向该类</span></span>
<span class="line"><span style="color:#e1e4e8;">6.call,apply,bind的this指向第一个参数</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">总结：this永远指向最后调用它的对象：</span></span>
<span class="line"><span style="color:#e1e4e8;">    1.如果函数中有this,若没有被上一级的对象调用，那就被window调用了，指向window；若被上一级的对象调用了，那就指向上一级对象</span></span>
<span class="line"><span style="color:#e1e4e8;">    2.如果函数中有this，且函数中包含多个对象，尽管函数是被最外层的对象调用的 但是this还是指向它的上一级对象</span></span>
<span class="line"><span style="color:#e1e4e8;">    3.当this遇到return， 如果return一个对象，this指向这个对象，不然this就指向函数的实例(返回null也是指向函数的实例)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">1.非严格模式下的全局环境,this指向window</span></span>
<span class="line"><span style="color:#24292e;">2.在对象中，属性的this指向外层this， 方法中的this指向调用它的对象</span></span>
<span class="line"><span style="color:#24292e;">3.回调函数中的this指向window（事件回调的this指向e.currentTarget）</span></span>
<span class="line"><span style="color:#24292e;">4.箭头函数中的this指向当前函数外的this（回调函数使用箭头函数时，this指向当前函数外的this）</span></span>
<span class="line"><span style="color:#24292e;">5.构造函数和类的this指向实例化对象,静态方法或属性的this指向该类</span></span>
<span class="line"><span style="color:#24292e;">6.call,apply,bind的this指向第一个参数</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">总结：this永远指向最后调用它的对象：</span></span>
<span class="line"><span style="color:#24292e;">    1.如果函数中有this,若没有被上一级的对象调用，那就被window调用了，指向window；若被上一级的对象调用了，那就指向上一级对象</span></span>
<span class="line"><span style="color:#24292e;">    2.如果函数中有this，且函数中包含多个对象，尽管函数是被最外层的对象调用的 但是this还是指向它的上一级对象</span></span>
<span class="line"><span style="color:#24292e;">    3.当this遇到return， 如果return一个对象，this指向这个对象，不然this就指向函数的实例(返回null也是指向函数的实例)</span></span></code></pre></div><h2 id="_30-高阶函数和回调函数" tabindex="-1">30.高阶函数和回调函数 <a class="header-anchor" href="#_30-高阶函数和回调函数" aria-label="Permalink to &quot;30.高阶函数和回调函数&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">1.高阶函数: 将函数作为入参或者返回值的函数</span></span>
<span class="line"><span style="color:#e1e4e8;">2.回调函数：被作为返回值的函数</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">1.高阶函数: 将函数作为入参或者返回值的函数</span></span>
<span class="line"><span style="color:#24292e;">2.回调函数：被作为返回值的函数</span></span></code></pre></div><h2 id="_31-promise" tabindex="-1">31.Promise <a class="header-anchor" href="#_31-promise" aria-label="Permalink to &quot;31.Promise&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">promise是一种异步编程解决方案。只要符合promise A+规范，就是一个promise。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">promise/A+规范中规定：</span></span>
<span class="line"><span style="color:#e1e4e8;">1.promise应该有三种状态，分别是初始状态pending（可改变），最终态fulfilled、rejected。其中，fulfilled必须有一个value值，rejected必须有一个reason</span></span>
<span class="line"><span style="color:#e1e4e8;">    promise可以通过resolve或reject方法将pending改为fulfilled或rejected,一旦改变后就不能再变</span></span>
<span class="line"><span style="color:#e1e4e8;">2.promise应该提供一个then方法，用来访问最终的结果。</span></span>
<span class="line"><span style="color:#e1e4e8;">    then方法接收两个参数 onFulfilled 和 onRejected,这两个参数必须是函数类型且应该是微任务，若参数不是函数，应该被忽略</span></span>
<span class="line"><span style="color:#e1e4e8;">    在状态变为fulfilled时，应该调用onFulfilled，参数是value,且只能调用一次</span></span>
<span class="line"><span style="color:#e1e4e8;">    在状态变为rejected时，应该调用onRejected， 参数是reason，且只能调用一次</span></span>
<span class="line"><span style="color:#e1e4e8;">    then方法返回一个promise且可以被多次调用</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">promise是一种异步编程解决方案。只要符合promise A+规范，就是一个promise。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">promise/A+规范中规定：</span></span>
<span class="line"><span style="color:#24292e;">1.promise应该有三种状态，分别是初始状态pending（可改变），最终态fulfilled、rejected。其中，fulfilled必须有一个value值，rejected必须有一个reason</span></span>
<span class="line"><span style="color:#24292e;">    promise可以通过resolve或reject方法将pending改为fulfilled或rejected,一旦改变后就不能再变</span></span>
<span class="line"><span style="color:#24292e;">2.promise应该提供一个then方法，用来访问最终的结果。</span></span>
<span class="line"><span style="color:#24292e;">    then方法接收两个参数 onFulfilled 和 onRejected,这两个参数必须是函数类型且应该是微任务，若参数不是函数，应该被忽略</span></span>
<span class="line"><span style="color:#24292e;">    在状态变为fulfilled时，应该调用onFulfilled，参数是value,且只能调用一次</span></span>
<span class="line"><span style="color:#24292e;">    在状态变为rejected时，应该调用onRejected， 参数是reason，且只能调用一次</span></span>
<span class="line"><span style="color:#24292e;">    then方法返回一个promise且可以被多次调用</span></span></code></pre></div><h2 id="_32-generator" tabindex="-1">32.Generator <a class="header-anchor" href="#_32-generator" aria-label="Permalink to &quot;32.Generator&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">一种特殊的函数，可以通过*关键字定义，yield关键字暂停执行并传递值，用于控制异步流程，一般与迭代器一起使用</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">一种特殊的函数，可以通过*关键字定义，yield关键字暂停执行并传递值，用于控制异步流程，一般与迭代器一起使用</span></span></code></pre></div><h2 id="_33-async-await" tabindex="-1">33.async/await <a class="header-anchor" href="#_33-async-await" aria-label="Permalink to &quot;33.async/await&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">一种异步编程解决方案，是生成器generator的语法糖，await返回一个Promise</span></span>
<span class="line"><span style="color:#e1e4e8;">async/await 让异步函数通过同步代码的展现形式展现，提高代码可读性</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">一种异步编程解决方案，是生成器generator的语法糖，await返回一个Promise</span></span>
<span class="line"><span style="color:#24292e;">async/await 让异步函数通过同步代码的展现形式展现，提高代码可读性</span></span></code></pre></div><h2 id="_34-事件循环" tabindex="-1">34.事件循环 <a class="header-anchor" href="#_34-事件循环" aria-label="Permalink to &quot;34.事件循环&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">浏览器中有多个进程，其中渲染进程是一个网页的重要一环</span></span>
<span class="line"><span style="color:#e1e4e8;">渲染进程中通过JS引擎线程来执行脚本，由于是单线程，所以为了提高运行效率，就引入了事件循环。</span></span>
<span class="line"><span style="color:#e1e4e8;">事件循环的核心思想是开辟一个消息队列用于存放各个线程加入的任务，然后通过JS引擎线程永久轮询消息队列中的任务并执行。</span></span>
<span class="line"><span style="color:#e1e4e8;">而消息队列中存在同步和异步任务，其中异步任务大致分为：</span></span>
<span class="line"><span style="color:#e1e4e8;">    1.前端计时器：setTimeout,setInterval</span></span>
<span class="line"><span style="color:#e1e4e8;">    2.前端异步:promise等</span></span>
<span class="line"><span style="color:#e1e4e8;">    3.网络通信： xhr fetch等</span></span>
<span class="line"><span style="color:#e1e4e8;">    4.用户交互回调： addEventListener</span></span>
<span class="line"><span style="color:#e1e4e8;">其次，JS引擎线程在取任务时，会有一个优先级，从高到底分别是：</span></span>
<span class="line"><span style="color:#e1e4e8;">    微任务队列： promise mutationObserver等</span></span>
<span class="line"><span style="color:#e1e4e8;">    交互队列： 用户交互后的回调</span></span>
<span class="line"><span style="color:#e1e4e8;">    延时队列： 计时器回调</span></span>
<span class="line"><span style="color:#e1e4e8;">    等</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">浏览器中有多个进程，其中渲染进程是一个网页的重要一环</span></span>
<span class="line"><span style="color:#24292e;">渲染进程中通过JS引擎线程来执行脚本，由于是单线程，所以为了提高运行效率，就引入了事件循环。</span></span>
<span class="line"><span style="color:#24292e;">事件循环的核心思想是开辟一个消息队列用于存放各个线程加入的任务，然后通过JS引擎线程永久轮询消息队列中的任务并执行。</span></span>
<span class="line"><span style="color:#24292e;">而消息队列中存在同步和异步任务，其中异步任务大致分为：</span></span>
<span class="line"><span style="color:#24292e;">    1.前端计时器：setTimeout,setInterval</span></span>
<span class="line"><span style="color:#24292e;">    2.前端异步:promise等</span></span>
<span class="line"><span style="color:#24292e;">    3.网络通信： xhr fetch等</span></span>
<span class="line"><span style="color:#24292e;">    4.用户交互回调： addEventListener</span></span>
<span class="line"><span style="color:#24292e;">其次，JS引擎线程在取任务时，会有一个优先级，从高到底分别是：</span></span>
<span class="line"><span style="color:#24292e;">    微任务队列： promise mutationObserver等</span></span>
<span class="line"><span style="color:#24292e;">    交互队列： 用户交互后的回调</span></span>
<span class="line"><span style="color:#24292e;">    延时队列： 计时器回调</span></span>
<span class="line"><span style="color:#24292e;">    等</span></span></code></pre></div><h2 id="_35-v8-隐藏类" tabindex="-1">35.V8 隐藏类 <a class="header-anchor" href="#_35-v8-隐藏类" aria-label="Permalink to &quot;35.V8 隐藏类&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">隐藏类是一种优化JS对象属性访问的机制，在JS中每创建一个对象，V8都会为其创建一个隐藏类。</span></span>
<span class="line"><span style="color:#e1e4e8;">隐藏类通过形状和内联缓存来提高属性访问的性能，可以提高JS代码的执行效率</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">隐藏类是一种优化JS对象属性访问的机制，在JS中每创建一个对象，V8都会为其创建一个隐藏类。</span></span>
<span class="line"><span style="color:#24292e;">隐藏类通过形状和内联缓存来提高属性访问的性能，可以提高JS代码的执行效率</span></span></code></pre></div><h2 id="_36-js-的运行机制" tabindex="-1">36.JS 的运行机制 <a class="header-anchor" href="#_36-js-的运行机制" aria-label="Permalink to &quot;36.JS 的运行机制&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">JS的运行机制是在浏览器执行的，主要分为三个阶段：解析，执行，渲染</span></span>
<span class="line"><span style="color:#e1e4e8;">解析阶段：浏览器会对HTML文档进行解析，生成DOM树和CSSOM树，同时如果HTML中包含JS代码，浏览器会将其解析生成抽象语法树</span></span>
<span class="line"><span style="color:#e1e4e8;">执行阶段：浏览器会逐行执行JS代码，执行过程中通过作用域链和执行上下文栈来管理变量和函数的访问权限：</span></span>
<span class="line"><span style="color:#e1e4e8;">    1.创建全局执行上下文</span></span>
<span class="line"><span style="color:#e1e4e8;">    2.浏览器预处理变量和函数声明，使得他们在执行阶段前可用</span></span>
<span class="line"><span style="color:#e1e4e8;">    3.逐行执行代码，遇到函数调用时，会创建一个新的执行上下文</span></span>
<span class="line"><span style="color:#e1e4e8;">    4.在每一个执行上下文中通过作用域链查找变量和函数的引用</span></span>
<span class="line"><span style="color:#e1e4e8;">    5.内存管理和垃圾回收</span></span>
<span class="line"><span style="color:#e1e4e8;">渲染阶段：JS引擎线程执行JS代码，且JS执行会阻塞页面渲染，同时通过消息队列 + 异步来提高运行效率</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">JS的运行机制是在浏览器执行的，主要分为三个阶段：解析，执行，渲染</span></span>
<span class="line"><span style="color:#24292e;">解析阶段：浏览器会对HTML文档进行解析，生成DOM树和CSSOM树，同时如果HTML中包含JS代码，浏览器会将其解析生成抽象语法树</span></span>
<span class="line"><span style="color:#24292e;">执行阶段：浏览器会逐行执行JS代码，执行过程中通过作用域链和执行上下文栈来管理变量和函数的访问权限：</span></span>
<span class="line"><span style="color:#24292e;">    1.创建全局执行上下文</span></span>
<span class="line"><span style="color:#24292e;">    2.浏览器预处理变量和函数声明，使得他们在执行阶段前可用</span></span>
<span class="line"><span style="color:#24292e;">    3.逐行执行代码，遇到函数调用时，会创建一个新的执行上下文</span></span>
<span class="line"><span style="color:#24292e;">    4.在每一个执行上下文中通过作用域链查找变量和函数的引用</span></span>
<span class="line"><span style="color:#24292e;">    5.内存管理和垃圾回收</span></span>
<span class="line"><span style="color:#24292e;">渲染阶段：JS引擎线程执行JS代码，且JS执行会阻塞页面渲染，同时通过消息队列 + 异步来提高运行效率</span></span></code></pre></div><h2 id="_37-cjs、amd、cmd" tabindex="-1">37.CJS、AMD、CMD <a class="header-anchor" href="#_37-cjs、amd、cmd" aria-label="Permalink to &quot;37.CJS、AMD、CMD&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">CJS、AMD、CMD都是用于JS中组织和管理模块的模块系统或规范</span></span>
<span class="line"><span style="color:#e1e4e8;">CJS：同步加载模块，模块会在代码执行时立即加载，通过require引入module.exports导出（node.js就是用了cjs）</span></span>
<span class="line"><span style="color:#e1e4e8;">AMD：异步加载模块，在定义模块时就声明其依赖，通过define定义，require引入（require.js用了）</span></span>
<span class="line"><span style="color:#e1e4e8;">CMD：异步加载模块，在使用模块时才声明其依赖，更加懒加载，通过define定义，require引入（sea.js用了）</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">CJS、AMD、CMD都是用于JS中组织和管理模块的模块系统或规范</span></span>
<span class="line"><span style="color:#24292e;">CJS：同步加载模块，模块会在代码执行时立即加载，通过require引入module.exports导出（node.js就是用了cjs）</span></span>
<span class="line"><span style="color:#24292e;">AMD：异步加载模块，在定义模块时就声明其依赖，通过define定义，require引入（require.js用了）</span></span>
<span class="line"><span style="color:#24292e;">CMD：异步加载模块，在使用模块时才声明其依赖，更加懒加载，通过define定义，require引入（sea.js用了）</span></span></code></pre></div><h2 id="_38-ajax" tabindex="-1">38.Ajax <a class="header-anchor" href="#_38-ajax" aria-label="Permalink to &quot;38.Ajax&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Ajax是一种用于在浏览器中进行异步通信的技术， 通常用于通过网络请求从服务器获取数据，而不用刷新整个页面</span></span>
<span class="line"><span style="color:#e1e4e8;">Ajax的核心是XMLHttpRequest</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">XMLHttpRequest的属性：</span></span>
<span class="line"><span style="color:#e1e4e8;">1.onreadystatechange 处理服务器响应</span></span>
<span class="line"><span style="color:#e1e4e8;">2.readyState 服务器响应的状态信息(0: 请求未初始化 1：请求提出 2：请求发送（可以获取头部信息） 3：请求处理中 4：请求已完成)</span></span>
<span class="line"><span style="color:#e1e4e8;">3.responseText 获取服务器返回数据</span></span>
<span class="line"><span style="color:#e1e4e8;">4.status 服务器HTTP状态码</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">XMLHttpRequest的方法：</span></span>
<span class="line"><span style="color:#e1e4e8;">1.open</span></span>
<span class="line"><span style="color:#e1e4e8;">2.send</span></span>
<span class="line"><span style="color:#e1e4e8;">3.setRequestHeader</span></span>
<span class="line"><span style="color:#e1e4e8;">4.abort 取消请求</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Ajax是一种用于在浏览器中进行异步通信的技术， 通常用于通过网络请求从服务器获取数据，而不用刷新整个页面</span></span>
<span class="line"><span style="color:#24292e;">Ajax的核心是XMLHttpRequest</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">XMLHttpRequest的属性：</span></span>
<span class="line"><span style="color:#24292e;">1.onreadystatechange 处理服务器响应</span></span>
<span class="line"><span style="color:#24292e;">2.readyState 服务器响应的状态信息(0: 请求未初始化 1：请求提出 2：请求发送（可以获取头部信息） 3：请求处理中 4：请求已完成)</span></span>
<span class="line"><span style="color:#24292e;">3.responseText 获取服务器返回数据</span></span>
<span class="line"><span style="color:#24292e;">4.status 服务器HTTP状态码</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">XMLHttpRequest的方法：</span></span>
<span class="line"><span style="color:#24292e;">1.open</span></span>
<span class="line"><span style="color:#24292e;">2.send</span></span>
<span class="line"><span style="color:#24292e;">3.setRequestHeader</span></span>
<span class="line"><span style="color:#24292e;">4.abort 取消请求</span></span></code></pre></div><h2 id="_39-axios" tabindex="-1">39.Axios <a class="header-anchor" href="#_39-axios" aria-label="Permalink to &quot;39.Axios&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Axios是一个基于promise的对Ajax的一种封装</span></span>
<span class="line"><span style="color:#e1e4e8;">优点：</span></span>
<span class="line"><span style="color:#e1e4e8;">    1.支持promise api</span></span>
<span class="line"><span style="color:#e1e4e8;">    2.拦截请求和相响应 axios.interceptors.request.use,axios.interceptors.response.use</span></span>
<span class="line"><span style="color:#e1e4e8;">    3.内置转换请求数据和响应数据，并对响应数据做JSON处理</span></span>
<span class="line"><span style="color:#e1e4e8;">    4.安全性更高，支持防御CSRF</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Axios是一个基于promise的对Ajax的一种封装</span></span>
<span class="line"><span style="color:#24292e;">优点：</span></span>
<span class="line"><span style="color:#24292e;">    1.支持promise api</span></span>
<span class="line"><span style="color:#24292e;">    2.拦截请求和相响应 axios.interceptors.request.use,axios.interceptors.response.use</span></span>
<span class="line"><span style="color:#24292e;">    3.内置转换请求数据和响应数据，并对响应数据做JSON处理</span></span>
<span class="line"><span style="color:#24292e;">    4.安全性更高，支持防御CSRF</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Axios取消请求推荐使用AbortController<br></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">controller</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AbortController</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;"> ​</span></span>
<span class="line"><span style="color:#E1E4E8;">    axios.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;/foo/bar&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#E1E4E8;">       signal: controller.signal</span></span>
<span class="line"><span style="color:#E1E4E8;">    }).</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">response</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;"> ​</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 取消请求</span></span>
<span class="line"><span style="color:#E1E4E8;">    controller.</span><span style="color:#B392F0;">abort</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">controller</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AbortController</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;"> ​</span></span>
<span class="line"><span style="color:#24292E;">    axios.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;/foo/bar&#39;</span><span style="color:#24292E;">, {</span></span>
<span class="line"><span style="color:#24292E;">       signal: controller.signal</span></span>
<span class="line"><span style="color:#24292E;">    }).</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">response</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#24292E;">    });</span></span>
<span class="line"><span style="color:#24292E;"> ​</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 取消请求</span></span>
<span class="line"><span style="color:#24292E;">    controller.</span><span style="color:#6F42C1;">abort</span><span style="color:#24292E;">();</span></span></code></pre></div></div><h2 id="跨域" tabindex="-1">跨域 <a class="header-anchor" href="#跨域" aria-label="Permalink to &quot;跨域&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">由于浏览器同源政策的限制，不同源会造成跨域（协议，域名，端口号其中一个或多个不同）</span></span>
<span class="line"><span style="color:#e1e4e8;">跨域解决方案：</span></span>
<span class="line"><span style="color:#e1e4e8;">1.jsonp： 解决get请求跨域，通过script标签的src不受同源政策限制的原理</span></span>
<span class="line"><span style="color:#e1e4e8;">2.postMessage： 解决多窗口、嵌套iframe之间的跨域数据传递</span></span>
<span class="line"><span style="color:#e1e4e8;">3.CORS跨域资源共享: 后端设置access-control-allow-origin</span></span>
<span class="line"><span style="color:#e1e4e8;">4.中间件代理：</span></span>
<span class="line"><span style="color:#e1e4e8;">    正向代理和反向代理</span></span>
<span class="line"><span style="color:#e1e4e8;">    正向代理：</span></span>
<span class="line"><span style="color:#e1e4e8;">        客户端向代理服务器发送请求并指定目标服务器，代理服务器再将请求发送给目标服务器。</span></span>
<span class="line"><span style="color:#e1e4e8;">        正向代理可以隐藏客户端真实IP，提供匿名访问和访问控制等功能</span></span>
<span class="line"><span style="color:#e1e4e8;">        常用于跨防火墙访问互联网、访问被封禁的网站</span></span>
<span class="line"><span style="color:#e1e4e8;">    反向代理：</span></span>
<span class="line"><span style="color:#e1e4e8;">        客户端发送请求到代理服务器，代理服务器判断请求的目标服务器然后发送</span></span>
<span class="line"><span style="color:#e1e4e8;">        客户端不能直接访问目标服务器，而是通过反向代理服务器来获取服务。</span></span>
<span class="line"><span style="color:#e1e4e8;">        反向代理可以实现负载均衡、高可用性和安全性等</span></span>
<span class="line"><span style="color:#e1e4e8;">        常用于高并发访问、保护后端服务器、提供缓存和SSL终止等</span></span>
<span class="line"><span style="color:#e1e4e8;">    区别：</span></span>
<span class="line"><span style="color:#e1e4e8;">        正向代理代理客户端，反向代理代理服务器</span></span>
<span class="line"><span style="color:#e1e4e8;">        正向代理隐藏客户端，反向代理隐藏服务器</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">由于浏览器同源政策的限制，不同源会造成跨域（协议，域名，端口号其中一个或多个不同）</span></span>
<span class="line"><span style="color:#24292e;">跨域解决方案：</span></span>
<span class="line"><span style="color:#24292e;">1.jsonp： 解决get请求跨域，通过script标签的src不受同源政策限制的原理</span></span>
<span class="line"><span style="color:#24292e;">2.postMessage： 解决多窗口、嵌套iframe之间的跨域数据传递</span></span>
<span class="line"><span style="color:#24292e;">3.CORS跨域资源共享: 后端设置access-control-allow-origin</span></span>
<span class="line"><span style="color:#24292e;">4.中间件代理：</span></span>
<span class="line"><span style="color:#24292e;">    正向代理和反向代理</span></span>
<span class="line"><span style="color:#24292e;">    正向代理：</span></span>
<span class="line"><span style="color:#24292e;">        客户端向代理服务器发送请求并指定目标服务器，代理服务器再将请求发送给目标服务器。</span></span>
<span class="line"><span style="color:#24292e;">        正向代理可以隐藏客户端真实IP，提供匿名访问和访问控制等功能</span></span>
<span class="line"><span style="color:#24292e;">        常用于跨防火墙访问互联网、访问被封禁的网站</span></span>
<span class="line"><span style="color:#24292e;">    反向代理：</span></span>
<span class="line"><span style="color:#24292e;">        客户端发送请求到代理服务器，代理服务器判断请求的目标服务器然后发送</span></span>
<span class="line"><span style="color:#24292e;">        客户端不能直接访问目标服务器，而是通过反向代理服务器来获取服务。</span></span>
<span class="line"><span style="color:#24292e;">        反向代理可以实现负载均衡、高可用性和安全性等</span></span>
<span class="line"><span style="color:#24292e;">        常用于高并发访问、保护后端服务器、提供缓存和SSL终止等</span></span>
<span class="line"><span style="color:#24292e;">    区别：</span></span>
<span class="line"><span style="color:#24292e;">        正向代理代理客户端，反向代理代理服务器</span></span>
<span class="line"><span style="color:#24292e;">        正向代理隐藏客户端，反向代理隐藏服务器</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>反向代理为什么叫反向代理<br> 从用户角度看，代理服务器被称为反向；从代理结构看。客户端与代理服务器属于一个局域网是正向，代理服务器和后端服务器在同一个局域网是反向</p></div>`,94),o=[e];function c(t,r,i,y,E,d){return a(),n("div",null,o)}const b=s(p,[["render",c]]);export{u as __pageData,b as default};
